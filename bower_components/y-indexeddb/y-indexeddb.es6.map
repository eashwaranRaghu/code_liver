{"version":3,"sources":["../yjs/node_modules/browser-pack/_prelude.js","src/IndexedDB.js"],"names":[],"mappings":";;;;;;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"y-indexeddb.es6","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global Y, IDBKeyRange, indexedDB, localStorage, IDBRequest, IDBOpenDBRequest, IDBCursor, IDBCursorWithValue, addEventListener */\n'use strict'\n// Thx to @jed for this script https://gist.github.com/jed/982883\nfunction generateGuid(a){return a?(a^Math.random()*16>>a/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,generateGuid)} // eslint-disable-line\n\nfunction extend (Y) {\n  Y.requestModules(['memory']).then(function () {\n    class Store {\n      constructor (transaction, name) {\n        this.store = transaction.objectStore(name)\n      }\n      * find (id) {\n        return yield this.store.get(id)\n      }\n      * put (v) {\n        yield this.store.put(v)\n      }\n      * delete (id) {\n        yield this.store.delete(id)\n      }\n      * findWithLowerBound (start) {\n        return yield this.store.openCursor(IDBKeyRange.lowerBound(start))\n      }\n      * findWithUpperBound (end) {\n        return yield this.store.openCursor(IDBKeyRange.upperBound(end), 'prev')\n      }\n      * findNext (id) {\n        return yield* this.findWithLowerBound([id[0], id[1] + 1])\n      }\n      * findPrev (id) {\n        return yield* this.findWithUpperBound([id[0], id[1] - 1])\n      }\n      * iterate (t, start, end, gen) {\n        var range = null\n        if (start != null && end != null) {\n          range = IDBKeyRange.bound(start, end)\n        } else if (start != null) {\n          range = IDBKeyRange.lowerBound(start)\n        } else if (end != null) {\n          range = IDBKeyRange.upperBound(end)\n        }\n        var cursorResult\n        if (range != null) {\n          cursorResult = this.store.openCursor(range)\n        } else {\n          cursorResult = this.store.openCursor()\n        }\n        while ((yield cursorResult) != null) {\n          yield* gen.call(t, cursorResult.result.value)\n          cursorResult.result.continue()\n        }\n      }\n      * flush () {}\n    }\n\n    function createStoreClone (Store) {\n      class Clone extends Store {\n        constructor () {\n          super(...arguments)\n          this.buffer = []\n          this._copyTo = null\n        }\n        // copy to this store\n        // it may be neccessary to reset this every time you create a transaction\n        copyTo (store) {\n          this._copyTo = store\n          return this\n        }\n        * put (v, dontCopy) {\n          if (!dontCopy) {\n            this.buffer.push(this._copyTo.put(v))\n          }\n          yield* super.put(v)\n        }\n        * delete (id) {\n          this.buffer.push(this._copyTo.delete(id))\n          yield* super.delete(id)\n        }\n        * flush () {\n          yield* super.flush()\n          for (var i = 0; i < this.buffer.length; i++) {\n            yield* this.buffer[i]\n          }\n          yield* this._copyTo.flush()\n        }\n      }\n      return Clone\n    }\n    Y.utils.createStoreClone = createStoreClone\n\n    var BufferedStore = Y.utils.createSmallLookupBuffer(Store)\n    // var ClonedStore = Y.utils.createStoreClone(Y.utils.RBTree)\n\n    class Transaction extends Y.Transaction {\n      constructor (store) {\n        super(store)\n        var transaction = store.db.transaction(['OperationStore', 'StateStore', 'DeleteStore'], 'readwrite')\n        this.store = store\n        this.ss = new BufferedStore(transaction, 'StateStore')\n        this.os = new BufferedStore(transaction, 'OperationStore')\n        // this._ds = new BufferedStore(transaction, 'DeleteStore')\n        // this.ds = store.dsClone.copyTo(this._ds)\n        this.ds = new BufferedStore(transaction, 'DeleteStore')\n      }\n    }\n    class OperationStore extends Y.AbstractDatabase {\n      constructor (y, options) {\n        /**\n         * There will be no garbage collection when using this connector!\n         * There may be several instances that communicate via localstorage,\n         * and we don't want too many instances to garbage collect.\n         * Currently, operationAdded (see AbstractDatabase) does not communicate updates to the garbage collector.\n         *\n         * While this could work, it only decreases performance.\n         * Operations are automatically garbage collected when the client syncs (the server still garbage collects, if there is any).\n         * Another advantage is that now the indexeddb adapter works with y-webrtc (since no gc is in place).\n         *\n         */\n        if (options.gc == null) {\n          options.gc = false\n        }\n        super(y, options)\n        // dsClone is persistent over transactions!\n        // _ds is not\n        // this.dsClone = new ClonedStore()\n        if (options == null) {\n          options = {}\n        }\n        this.options = options\n        if (options.namespace == null) {\n          if (y.options.connector.room == null) {\n            throw new Error('IndexedDB: expect a string (options.namespace)! (you can also skip this step if your connector has a room property)')\n          } else {\n            options.namespace = y.options.connector.room\n          }\n        }\n        if (options.idbVersion != null) {\n          this.idbVersion = options.idbVersion\n        } else {\n          this.idbVersion = 5\n        }\n        var store = this\n        // initialize database!\n        this.requestTransaction(function * () {\n          store.db = yield indexedDB.open(options.namespace, store.idbVersion)\n        })\n        if (options.cleanStart) {\n          if (typeof localStorage !== 'undefined') {\n            delete localStorage[JSON.stringify(['Yjs_indexeddb', options.namespace])]\n          }\n          this.requestTransaction(function * () {\n            yield this.os.store.clear()\n            yield this.ds.store.clear() // formerly only _ds\n            yield this.ss.store.clear()\n          })\n        }\n        this.whenUserIdSet(function (userid) {\n          if (typeof localStorage !== 'undefined' && localStorage[JSON.stringify(['Yjs_indexeddb', options.namespace])] == null) {\n            localStorage[JSON.stringify(['Yjs_indexeddb', options.namespace])] = JSON.stringify([userid, 0])\n          }\n        })\n        this.requestTransaction(function * () {\n          // this should be executed after the previous two defined transactions\n          // after we computed the upgrade event (see `yield indexedDB.open(..)`), we can check if userid is still stored on localstorage\n          var uid = null\n          if (typeof localStorage !== 'undefined') {\n            uid = localStorage[JSON.stringify(['Yjs_indexeddb', options.namespace])]\n          }\n          if (uid != null) {\n            store.setUserId(uid)\n            if (typeof localStorage !== 'undefined') {\n              var nextuid = JSON.parse(uid)\n              nextuid[1] = nextuid[1] + 1\n              localStorage[JSON.stringify(['Yjs_indexeddb', options.namespace])] = JSON.stringify(nextuid)\n            }\n          } else {\n            // wait for a 200ms before setting a random user id\n            setTimeout(function () {\n              if (store.userId == null) {\n                // the user is probably offline, so that the connector can't get a user id\n                store.setUserId(generateGuid()) // TODO: maybe it is best to always use a generated uid\n              }\n            }, 200)\n          }\n          // copy from persistent Store to non persistent StoreClone. (there could already be content in Store)\n          /*\n          yield* this._ds.iterate(this, null, null, function * (o) {\n            yield* this.ds.put(o, true)\n          })\n          */\n        })\n        var operationsToAdd = []\n        this.communicationObserver = function (op) {\n          operationsToAdd.push(op)\n          if (operationsToAdd.length === 1) {\n            store.requestTransaction(function * () {\n              var _toAdd = []\n              /*\n              There is a special case (see issue y-js/y-indexeddb#2) which we need to handle:\n              Assume a user creates a new type (lets say an Array) and then inserts something in it. Assume both operations are in operationsToAdd.\n              Since a type is initialized first, it already knows about the insertion, and we no longer need to call .operationAdded.\n              If we don't handle this case the type inserts the same operation twice.\n              => So wee need to filter out the operations whose parent is also inclduded in operationsToAdd!\n              */\n              for (var i = 0; i < operationsToAdd.length; i++) {\n                var op = operationsToAdd[i]\n                if (op.parent == null || operationsToAdd.every(function (p) {\n                  return !Y.utils.compareIds(p.id, op.parent)\n                })) {\n                  _toAdd.push(op)\n                }\n              }\n              operationsToAdd = []\n\n              for (i = 0; i < _toAdd.length; i++) {\n                yield* this.store.operationAdded(this, _toAdd[i], true)\n              }\n            })\n          }\n        }\n        Y.utils.localCommunication.addObserver(this.options.namespace, this.communicationObserver)\n      }\n      * operationAdded (transaction, op, noAdd) {\n        yield* super.operationAdded(transaction, op)\n        if (!noAdd) {\n          Y.utils.localCommunication.broadcast(this.options.namespace, op)\n        }\n      }\n      transact (makeGen) {\n        var transaction = this.db != null ? new Transaction(this) : null\n        var store = this\n\n        var gen = makeGen.call(transaction)\n        handleTransactions(gen.next())\n\n        function handleTransactions (result) {\n          var request = result.value\n          if (result.done) {\n            makeGen = store.getNextRequest()\n            if (makeGen != null) {\n              if (transaction == null && store.db != null) {\n                transaction = new Transaction(store)\n              }\n              gen = makeGen.call(transaction)\n              handleTransactions(gen.next())\n            } // else no transaction in progress!\n            return\n          }\n          // console.log('new request', request.source != null ? request.source.name : null)\n          if (request.constructor === IDBRequest) {\n            request.onsuccess = function () {\n              var res = request.result\n              if (res != null && res.constructor === IDBCursorWithValue) {\n                res = res.value\n              }\n              handleTransactions(gen.next(res))\n            }\n            request.onerror = function (err) {\n              gen.throw(err)\n            }\n          } else if (request.constructor === IDBCursor) {\n            request.onsuccess = function () {\n              handleTransactions(gen.next(request.result != null ? request.result.value : null))\n            }\n            request.onerror = function (err) {\n              gen.throw(err)\n            }\n          } else if (request.constructor === IDBOpenDBRequest) {\n            request.onsuccess = function (event) {\n              var db = event.target.result\n              handleTransactions(gen.next(db))\n            }\n            request.onerror = function () {\n              gen.throw(\"Couldn't open IndexedDB database!\")\n            }\n            request.onupgradeneeded = function (event) {\n              var db = event.target.result\n              if (typeof localStorage !== 'undefined') {\n                delete localStorage[JSON.stringify(['Yjs_indexeddb', store.options.namespace])]\n              }\n              if (db.objectStoreNames.contains('OperationStore')) {\n                // delete only if exists (we skip the remaining tests)\n                db.deleteObjectStore('OperationStore')\n                db.deleteObjectStore('DeleteStore')\n                db.deleteObjectStore('StateStore')\n              }\n              db.createObjectStore('OperationStore', {keyPath: 'id'})\n              db.createObjectStore('DeleteStore', {keyPath: 'id'})\n              db.createObjectStore('StateStore', {keyPath: 'id'})\n            }\n          } else {\n            gen.throw('You must not yield this type!')\n          }\n        }\n      }\n      // TODO: implement \"free\"..\n      * destroy () {\n        this.db.close()\n      }\n      deleteDB () {\n        Y.utils.localCommunication.removeObserver(this.options.namespace, this.communicationObserver)\n        indexedDB.deleteDatabase(this.options.namespace)\n        return Promise.resolve()\n      }\n    }\n    if (Y.utils.localCommunication == null) {\n      // localCommunication uses localStorage to communicate with all tabs / windows\n      // Using pure localStorage does not call the event listener on the tab the event is created on.\n      // Using this implementation the event is also called on the tab the event is created on.\n      Y.utils.localCommunication = {\n        observer: {},\n        addObserver: function (room, f) {\n          var listener = this.observer[room]\n          if (listener == null) {\n            listener = []\n            this.observer[room] = listener\n          }\n          listener.push(f)\n        },\n        removeObserver: function (room, f) {\n          this.observer[room] = this.observer[room].filter(function (g) { return f !== g })\n        },\n        broadcast: function (room, m) {\n          if (typeof localStorage !== 'undefined') {\n            localStorage.setItem(JSON.stringify(['__YJS__', room]), JSON.stringify(m))\n          }\n          this.observer[room].map(function (f) {\n            f(m)\n          })\n        }\n      }\n      if (typeof localStorage !== 'undefined') {\n        addEventListener('storage', function (event) {\n          var room\n          try {\n            var parsed = JSON.parse(event.key)\n            if (parsed[0] === '__YJS__') {\n              room = parsed[1]\n            } else {\n              return\n            }\n          } catch (e) { return }\n          var listener = Y.utils.localCommunication.observer[room]\n          if (listener != null) {\n            listener.map(function (f) {\n              f(JSON.parse(event.newValue))\n            })\n          }\n        })\n      }\n    }\n    Y.extend('indexeddb', OperationStore)\n  })\n}\n\nmodule.exports = extend\nif (typeof Y !== 'undefined') {\n  extend(Y)\n}\n"],"sourceRoot":"/source/"}