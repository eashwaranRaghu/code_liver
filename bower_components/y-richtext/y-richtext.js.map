{"version":3,"sources":["../yjs/node_modules/browser-pack/_prelude.js","src/Richtext.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","yRichtext","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","extend","Y","compareAttributes","b","constructor","Array","requestModules","then","YRichtext","_Y$Array$typeDefiniti","os","_model","_content","_classCallCheck","_this","_possibleConstructorReturn","Object","getPrototypeOf","instances","eventHandler","_pullChanges","forEach","instance","editor","update","_quillBlockFormats","_inherits","_createClass","key","value","attrs","keys","opAttributes","name","some","attr","q","val","unbindQuillAll","_get","prototype","map","v","join","createNewOp","op","attributes","insert","_this2","newLineCharacter","c","push","ops","hasOwnProperty","_formatAttributesForQuill","pos","content","curPos","selection","ins","split","curSel","endPos","delStart","delEnd","rightSel","undefined","end","from","to","attrName","attrValue","step2i","step2sel","antiAttrs","_v","deletes","_v2","j","del","performStep4","sel","delta","_quill","insLength","_sanitizeOpAttributes","select","delete","retain","afterRetain","additionalContent","getText","insertText","format","formatText","bindQuill","apply","arguments","unbindQuill","quill","findIndex","binding","yRichtextBinding","unobserve","yCallback","off","quillCallback","splice","mutualExcluse","token","applyDelta","event","type","valuePointer","values","vals","position","insertSel","index","unshift","typeDefinition","class","currText","d","updateContents","newSel","selectionStart","selectionEnd","k","removeFormat","myEvents","_i","deleteText","x","setContents","toDelta","on","observe","get","toString","utils","CustomTypeDefinition","struct","initType","regeneratorRuntime","mark","YTextInitializer","model","wrap","_context","prev","next","delegateYield","Struct","List","id","abrupt","stop","createType"],"mappings":"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","file":"y-richtext.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global Y */\n'use strict'\n\nfunction extend (Y) {\n  function compareAttributes (a, b) {\n    return a === b || (a == null && b == null) || (a != null && b != null && a.constructor === Array && a[0] === b[0] && a[1] === b[1])\n    /* the same as..\n    if (typeof a === 'string' || a == null) {\n      return a === b || a == null && b == null // consider undefined\n    } else {\n      return a[0] === b[0] && a[1] === b[1]\n    }\n    */\n  }\n  Y.requestModules(['Array']).then(function () {\n    class YRichtext extends Y.Array.typeDefinition['class'] {\n      constructor (os, _model, _content) {\n        super(os, _model, _content)\n        this.instances = []\n        // append this utility function with which eventhandler can pull changes from quill\n        this.eventHandler._pullChanges = () => {\n          this.instances.forEach(function (instance) {\n            instance.editor.update()\n          })\n        }\n        /*\n          According to Quills documentation, these are all block-formats.\n          If someone creates a custom format, it must be added here!\n            Blockquote - blockquote\n            Header - header\n            Indent - indent\n            List - list\n            Text Alignment - align\n            Text Direction - direction\n            Code Block - code-block\n        */\n        this._quillBlockFormats = [\n          'blockquote',\n          'header',\n          'indent',\n          'list',\n          'align',\n          'direction',\n          'code-block'\n        ]\n      }\n\n      _sanitizeOpAttributes (attrs) {\n        // return attrs\n        if (attrs == null || Object.keys(attrs).length === 0) {\n          return null\n        } else {\n          var opAttributes = {}\n          for (var name in attrs) {\n            if (this._quillBlockFormats.some(function (attr) { return attr === name })) {\n              opAttributes['_block'] = [name, attrs[name]]\n            } else {\n              opAttributes[name] = attrs[name]\n            }\n          }\n          return opAttributes\n        }\n      }\n      /*\n        Call this method before applying a format to quill.formatText()!\n      */\n      _formatAttributesForQuill (attrs) {\n        // sreturn attrs\n        var q = {}\n        for (var name in attrs) {\n          var val = attrs[name]\n          if (name === '_block') {\n            /*\n            // remove all existing block formats\n            this._quillBlockFormats.forEach(function (f) {\n              q[f] = false\n            })\n            */\n            if (val) {\n              // add format if val is truthy\n              q[attrs[name][0]] = attrs[name][1]\n            }\n          } else {\n            q[name] = val\n          }\n        }\n        return q\n      }\n      _destroy () {\n        this.unbindQuillAll()\n        super._destroy()\n      }\n      get length () {\n        /*\n          TODO: I must not use observe to compute the length.\n          But since I inherit from Y.Array, I can't set observe\n          the changes at the right momet (for that I would require direct access to EventHandler).\n          This is the most elegant solution, for now.\n          But at some time you should re-write Y.Richtext more elegantly!!\n        */\n        return this.toString().length\n      }\n      toString () {\n        return this._content.map(function (v) {\n          if (typeof v.val === 'string') {\n            return v.val\n          }\n        }).join('')\n      }\n      toDelta () {\n        // check last character\n        // insert a newline as the last character, if neccessary\n        // (quill will do that automatically otherwise..)\n        var newLineCharacter = false\n        for (var i = this._content.length - 1; i >= 0; i--) {\n          var c = this._content[i]\n          if (c.val.constructor !== Array) {\n            if (c.val === '\\n') {\n              newLineCharacter = true\n            }\n            break\n          }\n        }\n        if (!newLineCharacter) {\n          this.push('\\n')\n        }\n\n        // create the delta\n        var ops = []\n        var op = {\n          insert: [],\n          attributes: {}\n        }\n        function createNewOp () {\n          var attrs = {}\n          // copy attributes\n          for (var name in op.attributes) {\n            attrs[name] = op.attributes[name]\n          }\n          op = {\n            insert: [],\n            attributes: attrs\n          }\n        }\n        i = 0\n        for (; i < this._content.length; i++) {\n          let v = this._content[i].val\n          if (v.constructor === Array) {\n            if ((!op.attributes.hasOwnProperty(v[0]) && v[1] == null) || op.attributes[v[0]] === v[1]) {\n              continue\n            }\n            if (op.insert.length > 0) {\n              op.insert = op.insert.join('')\n              ops.push(op)\n              createNewOp()\n            }\n            if (v[1] === null) {\n              delete op.attributes[v[0]]\n            } else {\n              op.attributes[v[0]] = v[1]\n            }\n          } else if (typeof v === 'string') {\n            op.insert.push(v)\n          } else { // v is embed (Object)\n            if (op.insert.length > 0) {\n              op.insert = op.insert.join('')\n              ops.push(op)\n              createNewOp()\n            }\n            op.insert = v\n            ops.push(op)\n            createNewOp()\n          }\n        }\n        if (op.insert.length > 0) {\n          op.insert = op.insert.join('')\n          ops.push(op)\n        }\n        ops.forEach((op) => {\n          if (Object.keys(op.attributes).length === 0) {\n            delete op.attributes\n          } else {\n            op.attributes = this._formatAttributesForQuill(op.attributes)\n          }\n        })\n        return ops\n      }\n      insert (pos, content) {\n        var curPos = 0\n        var selection = {}\n        for (var i = 0; i < this._content.length; i++) {\n          if (curPos === pos) {\n            break\n          }\n          var v = this._content[i].val\n          if (v.constructor !== Array) {\n            curPos++\n          } else {\n            if (v[1] === null) {\n              delete selection[v[0]]\n            } else {\n              selection[v[0]] = v[1]\n            }\n          }\n        }\n        var ins\n        if (typeof content === 'string') {\n          ins = content.split('')\n        } else if (content.constructor === Object) {\n          ins = [content]\n        } else {\n          ins = content\n        }\n        super.insert(i, ins)\n        return selection\n      }\n      delete (pos, length) {\n        /*\n          let x = to be deleted string\n          let s = some string\n          let * = some selection\n          E.g.\n          sss*s***x*xxxxx***xx*x**ss*s\n               |---delete-range--|\n             delStart         delEnd\n\n          We'll check the following\n          * is it possible to delete some of the selections?\n            1. a dominating selection to the right could be the same as the selection (curSel) to delStart\n            2. a selections could be overwritten by another selection to the right\n        */\n        var curPos = 0\n        var curSel = {}\n        var endPos = pos + length\n        if (length <= 0) return\n        var delStart // relative to _content\n        var delEnd // ..\n        var v, i // helper variable for elements of _content\n\n        for (delStart = 0; curPos < pos && delStart < this._content.length; delStart++) {\n          v = this._content[delStart].val\n          if (v.constructor !== Array) {\n            curPos++\n          } else {\n            curSel[v[0]] = v[1]\n          }\n        }\n        for (delEnd = delStart; curPos < endPos && delEnd < this._content.length; delEnd++) {\n          v = this._content[delEnd].val\n          if (v.constructor !== Array) {\n            curPos++\n          }\n        }\n        if (delEnd === this._content.length) {\n          // yay, you can delete everything without checking\n          super.delete(delStart, delEnd - delStart)\n        } else {\n          if (v.constructor !== Array) {\n            delEnd--\n          }\n          var rightSel = {}\n          for (i = delEnd; i >= delStart; i--) {\n            v = this._content[i].val\n            if (v.constructor === Array) {\n              if (rightSel[v[0]] === undefined) {\n                if (compareAttributes(v[1], curSel[v[0]])) {\n                  // case 1.\n                  super.delete(i, 1)\n                }\n                rightSel[v[0]] = v[1]\n              } else {\n                // case 2.\n                super.delete(i, 1)\n              }\n            } else {\n              var end = i + 1\n              while (i > delStart) {\n                v = this._content[i - 1].val\n                if (v.constructor !== Array) {\n                  i--\n                } else {\n                  break\n                }\n              }\n              // always delete the strings\n              super.delete(i, end - i)\n            }\n          }\n        }\n      }\n      /*\n      1. get selection attributes from position $from\n         (name it antiAttrs, and we'll use it to make sure that selection ends in antiAttrs)\n      2. Insert selection $attr, if necessary\n      3. Between from and to, we'll delete all selections that do not match $attr.\n         Furthermore, we'll update antiAttrs, if necessary\n      4. In the end well insert a selection that makes sure that selection($to) ends in antiAttrs\n\n      Special case (which is quill related): There may only be one format on \\n.\n      If a user inserts a format on a newline character, all existing formats are deleted.\n      Quill denotes to these types of formats as block formats. The following block formats are defined:\n          Blockquote - blockquote\n          Header - header\n          Indent - indent\n          List - list\n          Text Alignment - align\n          Text Direction - direction\n          Code Block - code-block\n\n      */\n      select (from, to, attrName, attrValue) {\n        if (from == null || to == null || attrName == null || attrValue === undefined) {\n          throw new Error('You must define four parameters')\n        } else {\n          var step2i\n          var step2sel\n          var antiAttrs = [attrName, null]\n          var curPos = 0\n          var i = 0\n          // 1. compute antiAttrs\n          for (; i < this._content.length; i++) {\n            if (curPos === from) {\n              break\n            }\n            let v = this._content[i].val\n            if (v.constructor === Array) {\n              // selection\n              if (v[0] === attrName) { // compare names\n                antiAttrs[1] = v[1]\n              }\n            } else {\n              // embed or text\n              curPos++\n            }\n          }\n          // 2. Insert attr\n          if (!compareAttributes(antiAttrs[1], attrValue)) {\n            // we'll execute this later\n            step2i = i\n            step2sel = [attrName, attrValue]\n          }\n\n          // 3. update antiAttrs, modify selection\n          var deletes = []\n          for (; i < this._content.length; i++) {\n            if (curPos === to) {\n              break\n            }\n            let v = this._content[i].val\n            if (v.constructor === Array) {\n              // selection\n              if (v[0] === attrName) { // compare names\n                antiAttrs[1] = v[1]\n                deletes.push(i)\n              }\n            } else {\n              // embed or text\n              curPos++\n            }\n          }\n          // actually delete the found selections\n          // also.. we have to delete from right to left (so that the positions dont change)\n          for (var j = deletes.length - 1; j >= 0; j--) {\n            var del = deletes[j]\n            super.delete(del, 1)\n            // update i, rel. to\n            if (del < i) {\n              i--\n            }\n            if (del < step2i) {\n              step2i--\n            }\n          }\n          // 4. Update selection to match antiAttrs\n          // never insert, if not necessary\n          //  1. when it is the last position ~ i < _content.length)\n          //  2. when a similar attrName already exists between i and the next character\n          if (!compareAttributes(antiAttrs[1], attrValue) && i < this._content.length) { // check 1.\n            var performStep4 = true\n            var v\n            for (j = i; j < this._content.length; j++) {\n              v = this._content[j].val\n              if (v.constructor !== Array) {\n                break\n              }\n              if (v[0] === attrName) { // compare names\n                performStep4 = false // check 2.\n                if (compareAttributes(v[1], attrValue)) {\n                  super.delete(j, 1)\n                }\n                break\n              }\n            }\n            if (performStep4) {\n              var sel = [attrName, antiAttrs[1]]\n              super.insert(i, [sel])\n            }\n          }\n          if (step2i != null) {\n            super.insert(step2i, [step2sel])\n            // if there are some selections to the left of step2sel, delete them if possible\n            // * have same attribute name\n            // * no insert between step2sel and selection\n            for (j = step2i - 1; j >= 0; j--) {\n              v = this._content[j].val\n              if (v.constructor !== Array) {\n                break\n              }\n              if (v[0] === attrName) {\n                super.delete(j, 1)\n              }\n            }\n          }\n        }\n      }\n      /*\n        This method accepts a quill delta (http://quilljs.com/docs/deltas/)\n        The second parameter (_quill) is optional (it is only necessary when binding a quill instance)\n      */\n      applyDelta (delta, _quill) {\n        var pos = 0\n        var name // helper variable\n        for (var i = 0; i < delta.ops.length; i++) {\n          var op = delta.ops[i]\n          var opAttributes = this._sanitizeOpAttributes(op.attributes)\n          var attrs\n          var insLength\n          if (op.insert != null) {\n            if (typeof op.insert === 'string') {\n              attrs = this.insert(pos, op.insert)\n              insLength = op.insert.length\n            } else { // typeof is Object\n              attrs = this.insert(pos, op.insert)\n              insLength = 1\n            }\n            // create new selection\n            for (name in opAttributes) {\n              if (!compareAttributes(opAttributes[name], attrs[name])) {\n                this.select(pos, pos + insLength, name, opAttributes[name])\n              }\n            }\n            // not-existence of an attribute in opAttributes denotes\n            // that we have to unselect (set to null)\n            for (name in attrs) {\n              if (opAttributes == null || opAttributes[name] == null) {\n                this.select(pos, pos + insLength, name, null)\n              }\n            }\n            pos += insLength\n          }\n          if (op.delete != null) {\n            this.delete(pos, op.delete)\n          }\n          if (op.retain != null && _quill != null) {\n            var afterRetain = pos + op.retain\n            if (afterRetain > this.length) {\n              // debugger // TODO: check why this is still called..\n              // console.warn('Yjs internal: This should not happen')\n              let additionalContent = _quill.getText(this.length)\n              _quill.insertText(this.length, additionalContent)\n              // quill.deleteText(this.length + additionalContent.length, quill.getLength()) the api changed!\n              for (name in opAttributes) {\n                let format = {}\n                format[name] = false\n                format = this._formatAttributesForQuill(format)\n                // TODO: format expects falsy values now in order to remove formats\n                _quill.formatText(this.length + additionalContent.length, additionalContent.length, format)\n                // quill.deleteText(this.length, this.length + op.retain) the api changed!\n              }\n              this.insert(this.length, additionalContent)\n              // opAttributes = null\n            }\n            for (name in opAttributes) {\n              var attr = opAttributes[name]\n              this.select(pos, afterRetain, name, attr)\n              /*\n              let format = {}\n              format[name] = attr == null ? false : attr\n              format = this._formatAttributesForQuill(format)\n              if (name === '_block') {\n                var removeFormat = {}\n                this._quillBlockFormats.forEach((f) => { removeFormat[f] = false })\n                _quill.formatText(pos, op.retain, removeFormat)\n              }\n              _quill.formatText(pos, op.retain, format)\n              */\n            }\n            pos = afterRetain\n          }\n        }\n      }\n      bind () {\n        this.bindQuill.apply(this, arguments)\n      }\n      unbindQuillAll () {\n        for (var i = this.instances.length - 1; i >= 0; i--) {\n          this.unbindQuill(this.instances[i].editor)\n        }\n      }\n      unbindQuill (quill) {\n        var i = this.instances.findIndex(function (binding) {\n          return binding.editor === quill\n        })\n        if (i >= 0) {\n          var binding = this.instances[i]\n          binding.editor.yRichtextBinding = null\n          this.unobserve(binding.yCallback)\n          binding.editor.off('text-change', binding.quillCallback)\n          this.instances.splice(i, 1)\n        }\n      }\n      bindQuill (quill) {\n        var self = this\n\n        // this function makes sure that either the\n        // quill event is executed, or the yjs observer is executed\n        var token = true\n        function mutualExcluse (f) {\n          if (token) {\n            token = false\n            try {\n              f()\n            } catch (e) {\n              quill.update()\n              token = true\n              throw new Error(e)\n            }\n            quill.update()\n            token = true\n          }\n        }\n        if (quill.yRichtextBinding != null) {\n          quill.yRichtextBinding.unbindQuill(quill)\n        }\n        quill.setContents(this.toDelta())\n        quill.update()\n\n        function quillCallback (delta) {\n          mutualExcluse(function () {\n            self.applyDelta(delta, quill)\n          })\n        }\n        // TODO: Investigate if 'editor-change' is more appropriate!\n        quill.on('text-change', quillCallback)\n\n        function yCallback (event) {\n          mutualExcluse(function () {\n            var v // helper variable\n            var curSel // helper variable (current selection)\n            if (event.type === 'insert') {\n              var valuePointer = 0\n              while (valuePointer < event.values.length) {\n                var vals = []\n                while (valuePointer < event.values.length && event.values[valuePointer].constructor !== Array) {\n                  vals.push(event.values[valuePointer])\n                  valuePointer++\n                }\n                if (vals.length > 0) { // insert new content (text and embed)\n                  var position = 0\n                  var insertSel = {}\n                  for (var l = 0; l < event.index; l++) {\n                    v = self._content[l].val\n                    if (v.constructor !== Array) {\n                      position++\n                    } else {\n                      insertSel[v[0]] = v[1]\n                    }\n                  }\n                  // consider the case (this is markup): \"hi *you*\" & insert \"d\" at position 3\n                  // Quill may implicitely make \"d\" bold (dunno if thats true). Yjs, however, expects d not to be bold.\n                  // So we check future attributes and explicitely set them, if neccessary\n                  l = event.index + event.length\n                  while (l < self._content.length) {\n                    v = self._content[l].val\n                    if (v.constructor === Array) {\n                      if (!insertSel.hasOwnProperty(v[0])) {\n                        insertSel[v[0]] = null\n                      }\n                    } else {\n                      break\n                    }\n                    l++\n                  }\n                  // TODO: you definitely should exchange null with the new \"false\" approach..\n                  // Then remove the following! :\n                  for (var name in insertSel) {\n                    if (insertSel[name] == null) {\n                      insertSel[name] = false\n                    }\n                  }\n                  if (self.length === position + vals.length && vals[vals.length - 1] !== '\\n') {\n                    // always make sure that the last character is enter!\n                    var end = ['\\n']\n                    var sel = {}\n                    // now we remove all selections\n                    for (name in insertSel) {\n                      if (insertSel[name] !== false) {\n                        end.unshift([name, false])\n                        sel[name] = false\n                      }\n                    }\n                    Y.Array.typeDefinition.class.prototype.insert.call(self, position + vals.length, end)\n                    // format attributes before pushing to quill!\n                    quill.insertText(position, '\\n', self._formatAttributesForQuill(sel))\n                  }\n                  // create delta from vals\n                  var delta = []\n                  if (position > 0) {\n                    delta.push({ retain: position })\n                  }\n                  var currText = []\n                  vals.forEach(function (v) {\n                    if (typeof v === 'string') {\n                      currText.push(v)\n                    } else {\n                      if (currText.length > 0) {\n                        delta.push({\n                          insert: currText.join(''),\n                          attributes: insertSel\n                        })\n                        currText = []\n                      }\n                      delta.push({\n                        insert: v,\n                        attributes: insertSel\n                      })\n                    }\n                  })\n                  if (currText.length > 0) {\n                    delta.push({\n                      insert: currText.join(''),\n                      attributes: insertSel\n                    })\n                  }\n                  // format attributes before pushing to quill!\n                  delta.forEach(d => {\n                    if (d.attributes != null && Object.keys(d.attributes).length > 0) {\n                      d.attributes = self._formatAttributesForQuill(d.attributes)\n                    } else {\n                      delete d.attributes\n                    }\n                  })\n                  quill.updateContents(delta)\n                  // quill.insertText(position, vals.join(''), insertSel)\n                } else { // Array (selection)\n                  // a new selection is created\n                  // find left selection that matches newSel[0]\n                  curSel = null\n                  var newSel = event.values[valuePointer++] // get selection, increment counter\n                  // denotes the start position of the selection\n                  // (without the selection objects)\n                  var selectionStart = 0\n                  for (var j = event.index + valuePointer - 2/* -1 for index, -1 for incremented valuePointer */; j >= 0; j--) {\n                    v = self._content[j].val\n                    if (v.constructor === Array) {\n                      // check if v matches newSel\n                      if (newSel[0] === v[0]) { // compare names\n                        // found a selection\n                        // update curSel and go to next step\n                        curSel = v[1]\n                        break\n                      }\n                    } else {\n                      selectionStart++\n                    }\n                  }\n                  // make sure to decrement j, so we correctly compute selectionStart\n                  for (; j >= 0; j--) {\n                    v = self._content[j].val\n                    if (v.constructor !== Array) {\n                      selectionStart++\n                    }\n                  }\n                  // either a selection was found {then curSel was updated}, or not (then curSel = null)\n                  if (compareAttributes(newSel[1], curSel)) {\n                    // both are the same. not necessary to do anything\n                    continue\n                  }\n                  // now find out the range over which newSel has to be created\n                  var selectionEnd = selectionStart\n                  for (var k = event.index + valuePointer/* -1 for incremented valuePointer, +1 for algorithm */; k < self._content.length; k++) {\n                    v = self._content[k].val\n                    if (v.constructor === Array) {\n                      if (v[0] === newSel[0]) { // compare names\n                        // found another selection with same attr name\n                        break\n                      }\n                    } else {\n                      selectionEnd++\n                    }\n                  }\n                  // create a selection from selectionStart to selectionEnd\n                  if (selectionStart !== selectionEnd) {\n                    // format attributes before pushing to quill!!\n                    var format = {}\n                    format[newSel[0]] = newSel[1] == null ? false : newSel[1]\n                    format = self._formatAttributesForQuill(format)\n                    if (newSel[0] === '_block') {\n                      var removeFormat = {}\n                      self._quillBlockFormats.forEach((f) => { removeFormat[f] = false })\n                      quill.formatText(selectionStart, selectionEnd - selectionStart, removeFormat)\n                    }\n                    quill.formatText(selectionStart, selectionEnd - selectionStart, format)\n                  }\n                }\n              }\n            } else if (event.type === 'delete') {\n              // sanitize events\n              var myEvents = []\n              for (var i = 0, _i = 0; i < event.length; i++) {\n                if (event.values[i].constructor === Array) {\n                  if (i !== _i) {\n                    myEvents.push({\n                      type: 'text',\n                      length: i - _i,\n                      index: event.index\n                    })\n                  }\n                  _i = i + 1\n                  myEvents.push({\n                    type: 'selection',\n                    val: event.values[i],\n                    index: event.index\n                  })\n                }\n              }\n              if (i !== _i) {\n                myEvents.push({\n                  type: 'text',\n                  length: i - _i,\n                  index: event.index\n                })\n              }\n              // ending sanitizing.. start brainfuck\n              myEvents.forEach(function (event) {\n                if (event.type === 'text') {\n                  var pos = 0\n                  for (var u = 0; u < event.index; u++) {\n                    v = self._content[u].val\n                    if (v.constructor !== Array) {\n                      pos++\n                    }\n                  }\n                  quill.deleteText(pos, event.length)\n                } else {\n                  curSel = null\n                  var from = 0\n                  var x\n                  for (x = event.index - 1; x >= 0; x--) {\n                    v = self._content[x].val\n                    if (v.constructor === Array) {\n                      if (v[0] === event.val[0]) { // compare names\n                        curSel = v[1]\n                        break\n                      }\n                    } else {\n                      from++\n                    }\n                  }\n                  for (; x >= 0; x--) {\n                    v = self._content[x].val\n                    if (v.constructor !== Array) {\n                      from++\n                    }\n                  }\n                  var to = from\n                  for (x = event.index; x < self._content.length; x++) {\n                    v = self._content[x].val\n                    if (v.constructor === Array) {\n                      if (v[0] === event.val[0]) { // compare names\n                        break\n                      }\n                    } else {\n                      to++\n                    }\n                  }\n                  if (!compareAttributes(curSel, event.val[1]) && from !== to) {\n                    // format attributes before pushing to quill!!\n                    var format = {}\n                    format[event.val[0]] = curSel == null ? false : curSel\n                    format = self._formatAttributesForQuill(format)\n                    if (event.val[0] === '_block') {\n                      var removeFormat = {}\n                      self._quillBlockFormats.forEach((f) => { removeFormat[f] = false })\n                      quill.formatText(from, to - from, removeFormat)\n                    }\n                    quill.formatText(from, to - from, format)\n                  }\n                }\n              })\n            }\n            quill.update()\n          })\n        }\n        this.observe(yCallback)\n        this.instances.push({\n          editor: quill,\n          yCallback: yCallback,\n          quillCallback: quillCallback\n        })\n        quill.yRichtextBinding = this\n      }\n    }\n    Y.extend('Richtext', new Y.utils.CustomTypeDefinition({\n      name: 'Richtext',\n      class: YRichtext,\n      struct: 'List',\n      initType: function * YTextInitializer (os, model) {\n        var _content = []\n        yield * Y.Struct.List.map.call(this, model, function (op) {\n          if (op.hasOwnProperty('opContent')) {\n            throw new Error('Text must not contain types!')\n          } else {\n            op.content.forEach(function (c, i) {\n              _content.push({\n                id: [op.id[0], op.id[1] + i],\n                val: op.content[i]\n              })\n            })\n          }\n        })\n        return new YRichtext(os, model.id, _content)\n      },\n      createType: function YRichtextCreator (os, model) {\n        return new YRichtext(os, model.id, [])\n      }\n    }))\n  })\n}\n\nmodule.exports = extend\nif (typeof Y !== 'undefined') {\n  extend(Y)\n}\n"],"sourceRoot":"/source/"}